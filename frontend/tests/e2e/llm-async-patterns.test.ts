/**
 * LLM Async Code Patterns Test
 * 
 * Tests various async code patterns commonly generated by LLMs to ensure
 * tsx correctly executes them. These patterns often involve fire-and-forget
 * async function calls that need proper Promise handling.
 * 
 * Key patterns tested:
 * 1. async function declaration + call without await
 * 2. async arrow function + call without await  
 * 3. async IIFE without outer await
 * 4. Multiple async function calls in sequence
 * 5. Async functions with fetch (network I/O)
 * 6. Promise.then() chains
 * 7. Mixed sync and async code
 */

import { test, expect } from './webkit-persistent-fixture';
import type { Page } from '@playwright/test';

// Helper to execute commands through the sandbox worker
async function shellEval(page: Page, command: string): Promise<{ output: string; success: boolean; error?: string }> {
    const result = await page.evaluate(async (cmd) => {
        const harness = window.testHarness;
        if (!harness) {
            throw new Error('Test harness not initialized');
        }
        return await harness.shellEval(cmd);
    }, command);

    return result as { output: string; success: boolean; error?: string };
}

// Helper to write a file via the sandbox MCP tool
async function writeFile(page: Page, path: string, content: string): Promise<void> {
    await page.evaluate(async ({ path, content }) => {
        const harness = window.testHarness;
        if (!harness) {
            throw new Error('Test harness not initialized');
        }
        await harness.writeFile(path, content);
    }, { path, content });
}

test.describe('LLM Async Code Patterns', () => {
    test.beforeEach(async ({ page }) => {
        await page.goto('/wasm-test.html');
        await page.waitForFunction(() => {
            return window.testHarness?.ready === true;
        }, { timeout: 30000 });
    });

    test('async function declaration called without await', async ({ page }) => {
        // Common LLM pattern: define async function, call it at the end
        const script = `
async function main() {
    console.log('inside main');
    return 'done';
}
main()
`;
        await writeFile(page, '/test-async-decl.ts', script);
        const result = await shellEval(page, 'tsx /test-async-decl.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('inside main');
    });

    test('async arrow function called without await', async ({ page }) => {
        // LLM pattern: const fn = async () => { ... }; fn()
        const script = `
const runTask = async () => {
    console.log('task running');
    const x = 1 + 1;
    console.log('result:', x);
};
runTask()
`;
        await writeFile(page, '/test-async-arrow.ts', script);
        const result = await shellEval(page, 'tsx /test-async-arrow.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('task running');
        expect(result.output).toContain('result: 2');
    });

    test('async IIFE without outer await', async ({ page }) => {
        // LLM pattern: (async () => { ... })()
        const script = `
(async () => {
    console.log('IIFE executing');
    await Promise.resolve();
    console.log('after await');
})()
`;
        await writeFile(page, '/test-async-iife.ts', script);
        const result = await shellEval(page, 'tsx /test-async-iife.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('IIFE executing');
        expect(result.output).toContain('after await');
    });

    test('async function with fetch called without await', async ({ page }) => {
        // The key pattern that was broken: async fn with network I/O
        const script = `
async function fetchData() {
    console.log('starting fetch');
    const res = await fetch('https://httpbin.org/get');
    const data = await res.json();
    console.log('fetch complete, url:', data.url);
}
fetchData()
`;
        await writeFile(page, '/test-async-fetch.ts', script);
        const result = await shellEval(page, 'tsx /test-async-fetch.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('starting fetch');
        expect(result.output).toContain('fetch complete');
        expect(result.output).toContain('httpbin.org');
    });

    test('multiple async function calls in sequence', async ({ page }) => {
        // LLM might chain multiple async calls
        const script = `
async function step1() {
    console.log('step 1');
}

async function step2() {
    console.log('step 2');
}

async function step3() {
    console.log('step 3');
}

step1()
step2()
step3()
`;
        await writeFile(page, '/test-multi-async.ts', script);
        const result = await shellEval(page, 'tsx /test-multi-async.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        // Note: Only the last expression (step3()) is awaited by our wrapper,
        // but since these are all sync-completing, they should all print
        expect(result.output).toContain('step 1');
        expect(result.output).toContain('step 2');
        expect(result.output).toContain('step 3');
    });

    test('async function with internal await called without outer await', async ({ page }) => {
        // Async function that does internal awaits
        const script = `
async function doWork() {
    console.log('work start');
    await Promise.resolve('first');
    console.log('after first await');
    await Promise.resolve('second');
    console.log('after second await');
    return 'complete';
}
doWork()
`;
        await writeFile(page, '/test-internal-await.ts', script);
        const result = await shellEval(page, 'tsx /test-internal-await.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('work start');
        expect(result.output).toContain('after first await');
        expect(result.output).toContain('after second await');
    });

    test('Promise.then chain without await', async ({ page }) => {
        // LLM might use .then() chains
        const script = `
console.log('before chain');
Promise.resolve('value')
    .then(v => {
        console.log('then 1:', v);
        return v + '-modified';
    })
    .then(v => {
        console.log('then 2:', v);
    });
`;
        await writeFile(page, '/test-then-chain.ts', script);
        const result = await shellEval(page, 'tsx /test-then-chain.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('before chain');
        expect(result.output).toContain('then 1: value');
        expect(result.output).toContain('then 2: value-modified');
    });

    test('async class method pattern', async ({ page }) => {
        // LLM might generate class-based async code
        const script = `
class ApiClient {
    async getData() {
        console.log('getData called');
        return { status: 'ok' };
    }
}

const client = new ApiClient();
client.getData()
`;
        await writeFile(page, '/test-async-class.ts', script);
        const result = await shellEval(page, 'tsx /test-async-class.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('getData called');
    });

    test('nested async calls', async ({ page }) => {
        // LLM pattern: async function calling other async functions
        const script = `
async function inner() {
    console.log('inner executing');
    return 42;
}

async function outer() {
    console.log('outer start');
    const result = await inner();
    console.log('outer got:', result);
}

outer()
`;
        await writeFile(page, '/test-nested-async.ts', script);
        const result = await shellEval(page, 'tsx /test-nested-async.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('outer start');
        expect(result.output).toContain('inner executing');
        expect(result.output).toContain('outer got: 42');
    });

    test('async with try-catch error handling', async ({ page }) => {
        // LLM often adds error handling
        const script = `
async function safeOperation() {
    try {
        console.log('trying operation');
        await Promise.resolve();
        console.log('operation succeeded');
    } catch (e) {
        console.log('caught error');
    }
}
safeOperation()
`;
        await writeFile(page, '/test-async-trycatch.ts', script);
        const result = await shellEval(page, 'tsx /test-async-trycatch.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('trying operation');
        expect(result.output).toContain('operation succeeded');
    });

    test('async fetch with try-catch called without await', async ({ page }) => {
        // CRITICAL: This is the exact pattern that was broken
        // async fn() { try { await fetch(url) } catch {} } fn();
        const script = `
async function fetchWithErrorHandling() {
    console.log('starting request');
    try {
        const response = await fetch('https://httpbin.org/headers');
        const data = await response.json();
        console.log('request complete');
        console.log('has-headers:', Object.keys(data.headers).length > 0);
    } catch (e) {
        console.log('error:', e.message);
    }
}
fetchWithErrorHandling()
`;
        await writeFile(page, '/test-fetch-trycatch.ts', script);
        const result = await shellEval(page, 'tsx /test-fetch-trycatch.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('starting request');
        expect(result.output).toContain('request complete');
        expect(result.output).toContain('has-headers: true');
    });

    test('async function with setTimeout simulation', async ({ page }) => {
        // Common pattern for delays (though setTimeout may work differently in WASM)
        const script = `
async function delayed() {
    console.log('before delay');
    await new Promise(resolve => resolve(null));
    console.log('after delay');
}
delayed()
`;
        await writeFile(page, '/test-async-delay.ts', script);
        const result = await shellEval(page, 'tsx /test-async-delay.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('before delay');
        expect(result.output).toContain('after delay');
    });

    test('mixed sync and async with final async call', async ({ page }) => {
        // LLM might mix sync setup with async execution
        const script = `
const config = { url: 'test' };
console.log('config set:', config.url);

function syncHelper() {
    console.log('sync helper');
    return 'helped';
}

async function main() {
    const h = syncHelper();
    console.log('got help:', h);
    console.log('main complete');
}

main()
`;
        await writeFile(page, '/test-mixed-sync-async.ts', script);
        const result = await shellEval(page, 'tsx /test-mixed-sync-async.ts');

        console.log('Result:', result);
        expect(result.success).toBe(true);
        expect(result.output).toContain('config set: test');
        expect(result.output).toContain('sync helper');
        expect(result.output).toContain('got help: helped');
        expect(result.output).toContain('main complete');
    });
});
