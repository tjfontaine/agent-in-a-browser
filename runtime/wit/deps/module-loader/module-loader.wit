package mcp:module-loader@0.1.0;

/// Interface for lazy-loading WASM command modules
/// Provides subprocess-like interface for modules loaded on-demand
interface loader {
  /// Execution environment containing working directory and env vars
  record exec-env {
    cwd: string,
    vars: list<tuple<string, string>>,
  }

  /// Terminal dimensions (columns, rows)
  record terminal-size {
    cols: u32,
    rows: u32,
  }

  /// A pollable resource (from wasi:io/poll)
  use wasi:io/poll@0.2.9.{pollable};

  /// A handle to a lazy-loaded process
  resource lazy-process {
    /// Get a pollable that resolves when the process has output ready
    get-ready-pollable: func() -> pollable;
    
    /// Check if output is ready without blocking
    is-ready: func() -> bool;
    
    /// Write data to the process stdin
    write-stdin: func(data: list<u8>) -> u64;
    
    /// Close the stdin stream
    close-stdin: func();
    
    /// Read from stdout (up to max-bytes)
    read-stdout: func(max-bytes: u64) -> list<u8>;
    
    /// Read from stderr (up to max-bytes)
    read-stderr: func(max-bytes: u64) -> list<u8>;
    
    /// Try to get exit status without blocking (none if still running)
    try-wait: func() -> option<s32>;
    
    // ===== Terminal Control Methods =====
    
    /// Get current terminal dimensions
    get-terminal-size: func() -> terminal-size;
    
    /// Set terminal dimensions (for resize events from frontend)
    set-terminal-size: func(size: terminal-size);
    
    /// Enable/disable raw mode (unbuffered input, no echo)
    /// When enabled: each keystroke sent immediately, no line editing
    set-raw-mode: func(enabled: bool);
    
    /// Check if raw mode is currently enabled
    is-raw-mode: func() -> bool;
    
    /// Send signal to process (SIGINT=2, SIGTERM=15, etc.)
    send-signal: func(signum: u8);
  }

  /// Get the module name for a lazy-loaded command (none if not a lazy command)
  get-lazy-module: func(command: string) -> option<string>;

  /// Spawn a command in a lazy-loaded module
  spawn-lazy-command: func(
    module: string,
    command: string,
    args: list<string>,
    env: exec-env,
  ) -> lazy-process;

  /// Spawn an interactive command (enters raw mode automatically)
  /// Used for TUI applications that need character-by-character I/O
  spawn-interactive: func(
    module: string,
    command: string,
    args: list<string>,
    env: exec-env,
    size: terminal-size,
  ) -> lazy-process;

  /// Check if a command is an interactive TUI (needs direct terminal access)
  /// This queries the module registry to determine if a command should use
  /// spawn-interactive vs spawn-lazy-command
  is-interactive-command: func(command: string) -> bool;

  /// Check if JSPI (JavaScript Promise Integration) is available.
  /// When true, the runtime can use async/await for suspension, and 
  /// spawn-lazy-command should be preferred over spawn-worker-command
  /// to avoid module duplication issues in isolated Worker contexts.
  has-jspi: func() -> bool;

  /// Spawn a command in an isolated Web Worker (interruptible).
  /// Unlike spawn-lazy-command, this spawns ANY command (lazy or built-in)
  /// in its own Worker, enabling true interrupt via Worker.terminate().
  /// The Worker automatically loads the appropriate module.
  spawn-worker-command: func(
    command: string,
    args: list<string>,
    env: exec-env,
  ) -> lazy-process;
}
