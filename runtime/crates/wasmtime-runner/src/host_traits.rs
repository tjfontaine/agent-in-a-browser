//! Host trait implementations for bindgen-generated interfaces
//!
//! Implements the Host traits generated by wasmtime::component::bindgen!
//! for compile-time type safety of WIT interface implementations.

use std::process::{Command, Stdio};
use wasmtime::component::Resource;

use crate::bindings::{
    ExecEnv, HostLazyProcess, LazyProcess, LoaderExecEnv, ModuleLoaderHost, ShellCommandHost,
    TerminalDimensions, TerminalSize, TerminalSizeHost,
};
use crate::HostState;

// Use the remapped wasi:io types from wasmtime_wasi
use wasmtime_wasi::p2::bindings::io::poll::Pollable;
use wasmtime_wasi::p2::bindings::io::streams::{InputStream, OutputStream};

// ===== terminal:info/size Host implementation =====

impl TerminalSizeHost for HostState {
    fn get_terminal_size(&mut self) -> TerminalDimensions {
        let (cols, rows) = terminal_size::terminal_size()
            .map(|(w, h)| (w.0 as u32, h.0 as u32))
            .unwrap_or((80, 24));
        TerminalDimensions { cols, rows }
    }
}

// ===== shell:unix/command Host implementation =====

impl ShellCommandHost for HostState {
    fn run(
        &mut self,
        name: String,
        args: Vec<String>,
        env: ExecEnv,
        _stdin: Resource<InputStream>,
        _stdout: Resource<OutputStream>,
        _stderr: Resource<OutputStream>,
    ) -> i32 {
        let mut cmd = Command::new(&name);
        cmd.args(&args)
            .current_dir(&env.cwd)
            .stdin(Stdio::null())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        for (key, value) in &env.vars {
            cmd.env(key, value);
        }

        match cmd.output() {
            Ok(out) => {
                use std::io::Write;
                let _ = std::io::stdout().write_all(&out.stdout);
                let _ = std::io::stderr().write_all(&out.stderr);
                out.status.code().unwrap_or(-1)
            }
            Err(_) => -1,
        }
    }

    fn list_commands(&mut self) -> Vec<String> {
        vec![
            "ls", "cat", "echo", "pwd", "cd", "mkdir", "rm", "cp", "mv", "grep", "head", "tail",
            "wc", "sort", "uniq", "find", "xargs", "env", "export", "which", "clear", "date",
            "whoami", "uname", "vim", "vi", "sqlite3", "tsx", "tsc",
        ]
        .into_iter()
        .map(String::from)
        .collect()
    }
}

// ===== mcp:module-loader/loader Host implementation =====

impl ModuleLoaderHost for HostState {
    fn get_lazy_module(&mut self, command: String) -> Option<String> {
        self.module_loader.get_lazy_module(&command)
    }

    fn spawn_lazy_command(
        &mut self,
        module: String,
        command: String,
        args: Vec<String>,
        env: LoaderExecEnv,
    ) -> Resource<LazyProcess> {
        // Spawn using module_loader and get the process ID
        let _id = self
            .module_loader
            .spawn_lazy_command(&module, &command, args, env.cwd, env.vars);
        // Return a stub resource - real implementation needs resource table integration
        Resource::new_own(0)
    }

    fn spawn_interactive(
        &mut self,
        module: String,
        command: String,
        args: Vec<String>,
        env: LoaderExecEnv,
        _size: TerminalSize,
    ) -> Resource<LazyProcess> {
        let _id = self
            .module_loader
            .spawn_lazy_command(&module, &command, args, env.cwd, env.vars);
        Resource::new_own(0)
    }

    fn is_interactive_command(&mut self, command: String) -> bool {
        self.module_loader.is_interactive_command(&command)
    }

    fn has_jspi(&mut self) -> bool {
        false // Native doesn't need JSPI
    }

    fn spawn_worker_command(
        &mut self,
        command: String,
        args: Vec<String>,
        env: LoaderExecEnv,
    ) -> Resource<LazyProcess> {
        // Spawn as regular lazy command
        if let Some(module) = self.module_loader.get_lazy_module(&command) {
            let _id = self
                .module_loader
                .spawn_lazy_command(&module, &command, args, env.cwd, env.vars);
        }
        Resource::new_own(0)
    }
}

// ===== LazyProcess resource Host implementation =====

impl HostLazyProcess for HostState {
    fn get_ready_pollable(&mut self, _self_: Resource<LazyProcess>) -> Resource<Pollable> {
        // Stub - would need to create a proper pollable
        Resource::new_own(0)
    }

    fn is_ready(&mut self, _self_: Resource<LazyProcess>) -> bool {
        false
    }

    fn write_stdin(&mut self, _self_: Resource<LazyProcess>, _data: Vec<u8>) -> u64 {
        0
    }

    fn close_stdin(&mut self, _self_: Resource<LazyProcess>) {}

    fn read_stdout(&mut self, _self_: Resource<LazyProcess>, _max_bytes: u64) -> Vec<u8> {
        vec![]
    }

    fn read_stderr(&mut self, _self_: Resource<LazyProcess>, _max_bytes: u64) -> Vec<u8> {
        vec![]
    }

    fn try_wait(&mut self, _self_: Resource<LazyProcess>) -> Option<i32> {
        None
    }

    fn get_terminal_size(&mut self, _self_: Resource<LazyProcess>) -> TerminalSize {
        TerminalSize { cols: 80, rows: 24 }
    }

    fn set_terminal_size(&mut self, _self_: Resource<LazyProcess>, _size: TerminalSize) {}

    fn set_raw_mode(&mut self, _self_: Resource<LazyProcess>, _enabled: bool) {}

    fn is_raw_mode(&mut self, _self_: Resource<LazyProcess>) -> bool {
        false
    }

    fn send_signal(&mut self, _self_: Resource<LazyProcess>, _signum: u8) {}

    fn drop(&mut self, _rep: Resource<LazyProcess>) -> wasmtime::Result<()> {
        Ok(())
    }
}
